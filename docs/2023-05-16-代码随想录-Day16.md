[513. Find Bottom Left Tree Value](https://leetcode.cn/problems/find-bottom-left-tree-value/)

思路：
- 递归: 用中序遍历确保左节点最先visit，再记录最大深度
- BFS
```cpp
// 递归
class Solution {
public:
    int depth = INT_MIN;
    int res = 0;
    void traverse(TreeNode* root, int d) {
        if (!root) {
            return;
        }
        traverse(root->left, d + 1);
        if (!root->left && !root->right) {
            if (d > depth) {
                res = root->val;
                depth = d;
            }
            return;
        }
        traverse(root->right, d + 1);
    }
    int findBottomLeftValue(TreeNode* root) {
        traverse(root, 0);
        return res;
    }
};
```
[112. Path Sum](https://leetcode.cn/problems/path-sum/)

- 如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）
- 如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在236. 二叉树的最近公共祖先 (opens new window)中介绍）
- 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。